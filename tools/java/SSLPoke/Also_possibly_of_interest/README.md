# Ignoring Expired TLS Certificates in Java

This Gist shows how to make an HTTPS request in Java to a server with an expired HTTPS certificate. Expiration errors are silently ignored for one particular certificate, while all other validation rules are left intact. This whitelist-style behavior minimizes security risk, while still allowing you to communicate with the misconfigured server you are interested in.

### Using it
To use this code in your project (go ahead, it's in the public domain!) copy `IgnoreExpirationTrustManager into` your source tree and adapt `Example.buildContext()` and `Example.runDemo()` into your existing network code. When setting up the custom trust manager, pass in the SHA-1 fingerprint of the expired server certificate as the second argument. The SHA-1 fingerprint should be in uppercase hexadecimal, with no colons, spaces, or other separators. Only the server certificate, or leaf certificate, is handled by the code as written, so expired CA certificates will still raise exceptions.

### How it works
Dealing with TLS in Java, like many things, quickly runs into the factory-factory-factory problem. Starting from the top level, the demo code creates an SSL context with a custom set of trust managers, and uses the SSL context's socket factory in an `HttpsURLConnection`. Each `X509TrustManager` retrieved from the `TrustManagerFactory` is wrapped by the custom `IgnoreExpirationTrustManager` before being passed on to the `SSLContext`. The `IgnoreExpirationTrustManager` passes through most method calls to the wrapped trust manager, except `checkServerTrusted()`. Inside `checkServerTrusted()`, it computes the leaf certificate's fingerprint and compares it to the provided fingerprint of the expected expired certificate. If the fingerprint matches, it wraps the leaf certificate in a custom `EternalCertificate`, builds a new chain with the wrapped certificate, and then passes the modified chain along for verification by the wrapped trust manager. The `EternalCertificate` also passes most methods on to its wrapped certificate, except for the two `checkValidity()` methods. These methods normally check the `notBefore` and `notAfter` fields of the certificate against the current time, but instead we return without checking anything. Finally, these overridden methods accomplish our original goal of ignoring certificate expiration.
